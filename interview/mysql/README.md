# mysql

## 架构

- client
- server
- storage

## storage

- innodb: B+树
- myisam

## storage engine

### 考虑

- 读
  - 键查询
  - 小范围查询（磁盘IO）
  - 范围查询
- 写
- 空间

### 对比

- 数组/链表
  - 平均复杂度O(n)，慢
- 二叉树
  - 普通二叉树平均复杂度O(logn)，最坏复杂度O(n)，不稳定
  - 平衡二叉树最坏复杂度O(logn)，但对磁盘IO不友好
- 哈希表
  - 平均复杂度O(1)，不稳定
- 跳表
  - 平均复杂度O(logn)，不稳定
- B树
  - 从根节点开始，高度保持固定，每层有多个节点，每个节点有多个键/索引
  - 数据/记录存放在内部节点和叶子节点上
  - 稳定的键查询，对磁盘IO友好，不支持范围查询
- B+树
  - 从根节点开始，高度保持固定，每层有多个节点，每个节点有多个键/索引
  - 键/索引存放在内部节点上，数据/记录存放在叶子节点上，而且每层节点使用双向链表连接
  - 稳定的键查询，对磁盘IO友好，支持范围查询
- LSM
  - 读放大：compaction，bloomfilter
  - 空间放大：compaction

## index

- 主键/聚簇索引
  - 键：主键，值：记录
- 二级索引
  - 键：索引，值：主键
  - 回表
- 联合索引
  - 键：联合索引（顺序），值：主键
  - 回表

## explain

### 联合索引

- 不满足最左前缀匹配导致失效
- 范围查询右边的列失效

#### 例子

- `b = 1 and c = 2`: 缺少`a`，导致索引失效
- `a > 1 and b = 1`: 由于`a`是范围查询，导致`b = 1`失效
- `a > 1 and b > 2 and c > 3`: 不等价于`(a, b, c) > (1, 2, 3)`

#### 参考

- [【MySQL】索引失效以及explain应对](https://blog.csdn.net/tr1912/article/details/81319574)
- [一张图搞懂MySQL的索引失效](https://segmentfault.com/a/1190000021464570)
- [【原创】面试官:谈谈你对mysql联合索引的认识？](https://www.cnblogs.com/rjzheng/p/12557314.html)

## 慢sql

- 定位慢sql
- explain
- profile
- 优化慢sql

### 参考

- [MySQL优化(3)：慢SQL分析](https://www.cnblogs.com/zjxiang/p/9157398.html)
- [慢SQL优化一点小思路](https://juejin.cn/post/7048974570228809741)
- [慢SQL，压垮团队的最后一根稻草！](https://www.51cto.com/article/716344.html)

## log

### wal/steal/force

- wal：<T, A, x>需要先于脏数据落盘
- force：<T, COMMIT>需要后于脏数据落盘
- no force：<T, COMMIT>不需要后于脏数据落盘
- steal：<T, COMMIT>不需要先于脏数据落盘
- no steal：<T, COMMIT>需要先于脏数据落盘

### undo/redo

- undo：回滚日志，记录旧值，<T, A, x>
- redo：重做日志，记录新值，<T, A, x>
- undo/redo：<T, A, x1, x2>

### crasy recovery

#### redo <-> no force/no steal

- 原则: <T, A, x> -> <T, COMMIT> -> 脏数据
- 恢复
  - 已提交：重做
  - 未提交：无需操作

#### undo <-> force/steal

- 原则: <T, A, x> -> 脏数据 -> <T, COMMIT>
- 恢复
  - 已提交：无需操作
  - 未提交：回滚

#### undo/redo <-> steal/no force

- 原则: <T, A, x1, x2> -> 脏数据/<T, COMMIT>
- 恢复
  - 已提交：重做
  - 未提交：回滚

### binlog

- 用于主从同步
- 位于server层
- 格式
  - statement，基于SQL
  - row，基于记录
  - mixed

## transaction

- A：原子性
- C：一致性
- I：隔离性
- D：持久性

## 原子性

- log

## 一致性

- 一致性指数据库的数据无论何时都能保证某种逻辑的自洽
- 一致性主要通过下面的方式保证：
  - 事务的另外三个性质
  - 显示约束：数据库的约束功能
  - 隐式约束：业务代码

## 隔离性

### 问题

- 脏读：读取到其他事务未提交的数据
- 不可重复读：读取到其他事务提交的数据。准确的说，连续读取同一条记录，但值不同
- 更新丢失：由于隔离性，两个事务在无法相互可见的情况下，并发的修改同一条记录
- 幻读：读取到其他事务新增的数据。准确的说，连续读取同一张表，但记录个数不同

### 隔离级别

- 读未提交：脏读
- 读提交：解决脏读
- 可重复读：解读不可重复读和更新丢失
- 串行化：解决幻读

### MVCC（多版本并发控制）

- 使用一致性视图/快照执行事务：每个一致性试图/快照都有一个唯一递增的ID，并在新增和更新数据的时候，给数据增加一个版本号，使用该ID标记
- 一致性视图/快照遵循如下原则：
  - 自身的事务可见
  - 未提交的事务不可见
  - 创建一致性视图/快照之前的提交的事务可见
  - 创建一致性视图/快照之后的提交的事务不可见

### 锁

- 读写锁
- 表锁
- 行锁
- 间隙锁

### 读未提交

- log

### 读提交

- MVCC：事务中，在每个SQL语句执行开始时，创建一个一致性视图/快照

### 可重复读

- MVCC：在事务开始时，创建一个一致性视图/快照
- 锁：小粒度

### 串行化

- 锁：大粒度

### 参考

- [什么是脏读、不可重复读、幻读？](https://www.zhihu.com/question/458275373/answer/1873975439)
- [我以为我对Mysql事务很熟，直到我遇到了阿里面试官](https://zhuanlan.zhihu.com/p/148035779)

## 持久性

- log
